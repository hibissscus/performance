ğŸ”ğŸ•µï¸â€â™‚ï¸ğŸ“‹ï¸ **Performance Investigation** of  [PrimeCalculator](https://github.com/hibissscus/performance/blob/master/src/main/java/PrimeCalculator.java)
=================================

CPU hot spots of performance test results generated by profiler [YourKit](https://www.yourkit.com/java/profiler/) for max prime number **100.000**
![100000_cpu_hot_spots.png](profiler/100000_cpu_hot_spots.png)

CPU call tree by thread for max prime number **100.000**
![100000_cpu_call_tree.png](profiler/100000_cpu_call_tree.png)

Memory for max prime number **100.000**
![100000_memory.png](profiler/100000_memory.png)

List of performance issues:
=================================
ğŸ“‰ **CPU high load**: a lot of CPU time spent on the collection synchronization based on CPU hot spots ![synchronized_list.png](readme/synchronized_list.png)

ğŸ§ ğŸ’¥ **Out of memory**: heap space issue due too many new instances of ***BigIntegerIterator*** object creation in case of big prime number (ex. 1000000) ![big_integer_iterator_out_of_memory.png](readme/big_integer_iterator_out_of_memory.png) ![out_of_memory.png](readme/out_of_memory.png)

ğŸ‹ï¸â€â™‚ï¸ **Too ambition thread pool size**: thread pool size can be too big in case of big prime number (ex. 1.000.000) ![ambitious_thread_pool.png](readme/ambitious_thread_pool.png)

ğŸ’° **Expensive operation**: inside **isPrime** method expensive operation ***subList*** is used inside the for-loop
![sub_list.png](readme/sub_list.png)

ğŸ”¡ **Excess concatenation**: instead of concatenations **System.out.println(prime)** can be used
![main_println.png](readme/main_println.png)

Code style refactoring:
=================================
ğŸš« **Unnecessary class BigIntegerIterator**: this class is redundant, but still if needed to use it some code can be refactored
![big_integer_iterator.png](readme/big_integer_iterator.png)

ğŸš¨ **Unnecessary use of Exception**: would be better to use boolean as a return value instead of exceptions
![exception.png](readme/exception.png)
![thrown_exception.png](readme/thrown_exception.png)

Optimized version of [PrimeCalculator](https://github.com/hibissscus/performance/blob/master/src/main/java/PrimeCalculatorOptimized.java)
=================================
Here are some potential improvements that could be made to the code:

ğŸ’» **Use a more efficient algorithm for finding primes**: current implementation uses a simple trial division approach, which is slow for large values of maxPrime.
![efficient_algorithm.png](readme/efficient_algorithm.png)

ğŸ¯ **Use the IntStream instead of Stream**: since the BigIntegerIterator class is only used to generate a sequence of integers, to simplify the code by using the IntStream class instead of the Stream class. This can make the code more concise and easier to read. 
![int_stream.png](readme/int_stream.png)

âœ… **Remove unnecessary Exception handling**: isPrime method throws an Exception when a non-prime number is found, but this is unnecessary since the method is only called in a try-catch block, and the caught exception is ignored. Instead of throwing an exception, the method could return a boolean value indicating whether the number is prime or not.
![boolean_instead_exceptiuon.png](readme/boolean_instead_exceptiuon.png)

ğŸ¤ **Remove unnecessary synchronization**: [PrimeCalculatorSimple.java](https://github.com/hibissscus/performance/blob/master/src/main/java/PrimeCalculatorSimple.java)

ğŸš€ **Full version of optimized class**: [PrimeCalculatorOptimized.java](https://github.com/hibissscus/performance/blob/master/src/main/java/PrimeCalculatorOptimized.java)
![prime_calculator_optimized.png](readme/prime_calculator_optimized.png)

ğŸš€ **Full version of optimized class**: [PrimeCalculatorOptimizedV2.java](https://github.com/hibissscus/performance/blob/master/src/main/java/PrimeCalculatorOptimizedV2.java)
![prime_calculator_optimized_v2.png](readme/prime_calculator_optimized_v2.png)

Performance improvement after optimization:
=================================
ğŸš€ **Execution time improvement**: significant improvement on time of the program execution (ex. 100.000) ![comparison_optimized_call_tree.png](profiler/comparison_optimized_call_tree.png)

ğŸ§  **Heap size memory improvement**: less unnecessary object was created after optimization (ex. 100.000) ![comparison_optimized_classes.png](profiler/comparison_optimized_classes.png) 
![comparison_memory.png](profiler/comparison_memory.png)

ğŸ’¾ **Memory comparison**: for original version with maxPrime (ex. 100.000) and optimized version (100.000.000)
![comparison_memory_optimized.png](profiler/comparison_memory_optimized.png)

âœ… **Fewer exceptions**: less unnecessary exceptions generated during execution ![comparison_optimized_exceptions.png](profiler/comparison_optimized_exceptions.png)

Next version of optimization [Sieve of Eratosthenes](https://github.com/hibissscus/performance/blob/master/src/main/java/PrimeSieveOfEratosthenes.java):
=================================
ğŸ§º **Sieve of Eratosthenes**: the algorithm works by iteratively marking the multiples of each prime number as composite, starting from the smallest prime (2) and continuing until the square of the current prime exceeds the given limit.

- Create a list of consecutive integers from 2 to the given limit.
- Let the current prime number be initialized as 2.
- Mark all the multiples of 2 as composite (not prime).
- Find the next prime number (the smallest number greater than the current prime that is not marked as composite).
- Repeat steps 3 and 4 until the square of the current prime exceeds the given limit.
- All the remaining unmarked numbers in the list are prime numbers.

ğŸš€ **Execution time improvement**: significant improvement on time of the program execution (ex. 100.000) ![100000_sieve_of_eratosthenes_algorithm.png](profiler/100000_sieve_of_eratosthenes_algorithm.png)
### Authors

Â© 2023 [Sergei Stepanov](https://github.com/hibissscus) (implementation & enhancement)
